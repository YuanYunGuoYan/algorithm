第7 章 排序

不能在主存中完成而必须在磁盘或磁带上完成的排序叫做外部排序

目标（内部排序）

1. 存在几种容易的算法以 O（N2）完成排序

2. 有一种算法叫做希尔排序，它编程非常简单，以 O（N2）运行，并在实践中很有效

3. 存在一些稍微复杂的0（N log N）的排序算法

4. 任何通用的排序算法均需要Ω（N log N）此比较


7.1 预备知识

正如1.4 节所描述，被排序的对象属于Comparable类型，因此我们使用CompareTp方法对输入数据施加相容排序，除引用赋值运算外，这是仅有的允许对输入数据进行的操作，在这些条件下的排序叫做基于比较的排序


7.2 插入排序
7.2.1 算法

最简单的排序算法之一是 插入排序 插入排序由N—1趟排序组成，对于P=1到N - 1,插入排序保证了从位置0到 p-1的位置已处于排序状态

第P趟我们将位置P上的元素向左移动，知道它在前P+1个元素中找到正确的位置





















蓝色字体实现数据移动而没有明显的使用交换，位置在P上的元素存储于tmp中而（在位置p之前）所有的更大的元素都被向右移动一个位置，然后tmp被置于正确位置
7.2.2 插入排序分析

由于嵌套循环的每一次都要执行N此迭代，因此插入排序为O（N2），而且这个界是精确的，因此每次以反序的输入可以达到该界

另一方面如果数据一斤排序那么运行时间为0（N）
7.3 一些简单排序算法的下届

逆序：数组中 i < j  a[i] > a[j] 的性质的元素称为逆序

可以通过计算排列中的平均逆序树得出排序平均运行时间的精确的界

N个互异树的数组平均逆序树是 N（N-1）/4


7.4 希尔排序（插入排序的一种）

该算法是冲破二次时间屏障的第一批算法之一，不过，诺干年后才被证明它的二次时间界

它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到比较相邻两项为止。由于这个原因，希尔排序有时也叫作缩减增量排序



希尔排序使用一个序列，h1 ,h2 ,...,ht 叫作增量系列，在使用hk排序后，对于每一个i我们都有a[i] <= a[i+k},此时所有想个K的元素都别排序了，此时称为文件的hk排序



希尔排序是基于插入排序的以下两点性质而提出改进方法的

1. 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。

2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

使用希尔排序最坏情景运算时间为O（N2）























使用Hibbard增量的希尔排序最坏时间复杂度为O（N3/2）

Hibbard 增量 形如 1，3，7, ....,2K-1
7.5堆排序

优先队列可以使用O（N log N）的时间排序，基本思想的算法叫做堆排序，他给出我们至今所见到的最佳的大O运行时间

1.建立N个元素的二叉堆的，这个阶段花费O（N）时间，最多用到2N次比较

2.然后我们执行N此deleteMin操作，按照规则最小的元素先离开队列，通过把这些元素记录在第二个数组 这阶段花费O（log N） 最多用到2N logN -O(N)次比较、

因此总运行时间为O（N log N） 最多用到2N logN -O(N)次比较、

该算法需要多增加一倍的空间


7.6 归并排序

归并排序以O(Nlog N)最坏时间运行，而使得使用的比较次数是最优的，它是递归算法的好实例

该算法的基本操作时合并两个已排序的表，因为两个表时已排序的，所以将输出放到第三个表中。则该算法可以通过对输入数据一趟排序来完成。基本的合并算法是去两个输入数组A和B，一个输入数组C，以及3个计数器

分治策略 它将问题分成一些小问题然后递归求解
7.7 快速排序

快速排序是实践中的一种快速排序算法，它的平均运行时间为O(Nlog N) 最坏运行时间为0（N2）但是经过努力这种情况就很难出现 该算法之所以块是因为 非常精炼和高度优化的内部循环。

快排的效率一般还是不错的，事实上，如果表中含有大量的重复项，以及相对较少的不同项，其表现还是不错的

该算法会参数额外的空间，因此我们必须避免使用大量额外的内存，应该避免建立第二组（包含等于项的） 细节会影响排序效率
7.7.3 小数组

对于很小的数组，快速排序不如插入排序（N < 20）
7.8 排序算法的一般下届

虽然我们得到了一些O（Nlog N）的排序算法，但是，尚不清楚我们是否还能做更好。我们证明，任何只用到比较排序算法的最坏情况都需要Ω（N log N）此比较，因此归并排序和堆排序在一个常数因子范围内都是最优秀的。这也意味着拍数排序在相差一个常数因子的时候时最优秀的

只用到比较的任何排序算法在最坏情况下都需要（log(N!)）此比较



策略树 （二叉树）

策略树是证明下届的抽象概念，给个节点表示在元素之间一组可能的排序，每一个节点之间一组可能的排序。


7.9 选择问题的决策树下届

任意基于比较排序算法都必须用到大约N log N此比较，
7.11 线性时间的排序 桶排序和基数排序

在某一些特殊情况下以线性时间进行排序任然是可能的 ，一个简单的例子是桶排序

桶排序 ： 使用大小为M（元素小于M）的称为count的数组，初始化全部为0于是count有了M个单元（或称为桶），初始化为空，当读入Ai时count增加一，在所有内容都别输入后，扫描数组。该算法的用时O（M+N）,如果M为O(N),那么总用时就是O（N）

适用于一些小整数的情况

基数排序 一般的 对某常数考虑值域从0 ~ bp 的数字，显然不能使用桶排序，窍门是使用多次桶排序。自然的算法是对最高位的数字用桶排序，在对此高位排序。。。。


7.12 外部排序

迄今为止我们考察的算法都是输入数据装入内存，然而存在一些应用，他们输入的数据量太大了，装不进内存。本节将谈论这些外部排序算法，他们是设计来处理很大的数据的

如果数据在硬盘上，由于磁盘转动和移动磁头所需要的时间，会使效率损失


7.12.3 简单算法

基本的外部排序算法使用归并排序中的合并算法

外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的


小结

对于大部分一般的内部排序的运用都是 插入排序，希尔排序，归并排序就是快速排序，这主要是底层环境来决定的。

插入排序使用于非常少量是输入

对于中等附魔的输入 希尔排序是一个不错的选择，它可以用少了代码就能给出优异的表现

归并排序在最坏情况下变现O（logN），但需要额外的空间然而，它用到的比较次数几乎是最优的